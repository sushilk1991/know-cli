"""Documentation generator."""

import json
from pathlib import Path
from typing import TYPE_CHECKING, Any, Dict, List, Optional

if TYPE_CHECKING:
    from know.config import Config
    from know.scanner import APIRoute


class DocGenerator:
    """Generates documentation from codebase structure."""
    
    def __init__(self, config: "Config"):
        self.config = config
        self.output_dir = config.root / config.output.directory
    
    def generate_all(self) -> None:
        """Generate all documentation."""
        from know.scanner import CodebaseScanner
        
        scanner = CodebaseScanner(self.config)
        structure = scanner.get_structure()
        
        # Generate each type of doc
        self.generate_system_doc(structure)  # Default: docs/arc.md
        self.generate_c4_diagram(structure)
        
        routes = scanner.extract_api_routes()
        if routes:
            self.generate_openapi(routes)
    
    def generate_system_doc(self, structure: Dict[str, Any], output: Optional[str] = None) -> Path:
        """Generate system documentation (arc.md or similar)."""
        from know.ai import AISummarizer
        
        ai = AISummarizer(self.config)
        intro = ai.generate_readme_intro(structure)
        
        # Check if intro already has a title (fallback does)
        if intro.strip().startswith("# "):
            lines = [intro, "", "## ðŸ“ Project Structure", ""]
        else:
            lines = [
                f"# {self.config.project.name}",
                "",
                intro,
                "",
                "## ðŸ“ Project Structure",
                "",
            ]
        
        # Add module overview
        for module in structure.get("modules", [])[:15]:
            desc = module.get("description", "")
            if desc:
                desc = desc.split("\n")[0][:100]
                lines.append(f"- **[{module['name']}]({module['path']})** - {desc}")
            else:
                lines.append(f"- **[{module['name']}]({module['path']})**")
        
        if len(structure.get("modules", [])) > 15:
            lines.append(f"- ... and {len(structure['modules']) - 15} more modules")
        
        lines.extend([
            "",
            "## ðŸ“Š Statistics",
            "",
            f"- **Files:** {structure.get('file_count', 'N/A')}",
            f"- **Modules:** {structure.get('module_count', 'N/A')}",
            f"- **Functions:** {structure.get('function_count', 'N/A')}",
            f"- **Classes:** {structure.get('class_count', 'N/A')}",
            "",
            "---",
            "",
            f"*Generated by [know](https://github.com/sushilk1991/know-cli) v{self.config.project.version}*",
            "",
            "Run `know update` to refresh this documentation.",
        ])
        
        content = "\n".join(lines)
        
        if output:
            path = Path(output)
        else:
            # Default to docs/arc.md instead of README.md
            path = self.output_dir / "arc.md"
        
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content)
        return path
    
    def generate_readme(self, structure: Dict[str, Any], output: Optional[str] = None) -> Path:
        """Generate enhanced README.md (legacy, kept for backward compatibility)."""
        return self.generate_system_doc(structure, output)
    
    def generate_c4_diagram(
        self,
        structure: Dict[str, Any],
        output: Optional[str] = None
    ) -> Path:
        """Generate C4 architecture diagram."""
        if self.config.diagrams.format == "mermaid":
            return self._generate_mermaid_diagram(structure, output)
        else:
            return self._generate_c4_plantuml(structure, output)
    
    def _generate_mermaid_diagram(
        self,
        structure: Dict[str, Any],
        output: Optional[str] = None
    ) -> Path:
        """Generate Mermaid diagram."""
        lines = [
            "# Architecture Diagram",
            "",
            "```mermaid",
            "graph TB",
        ]
        
        # Add modules as nodes
        for i, module in enumerate(structure.get("modules", [])[:20]):
            node_id = f"M{i}"
            name = module['name'].split('.')[-1]
            lines.append(f'    {node_id}["{name}"]')
        
        lines.extend([
            "```",
            "",
            "*Generated by know*",
        ])
        
        content = "\n".join(lines)
        
        if output:
            path = Path(output)
        else:
            self.output_dir.mkdir(parents=True, exist_ok=True)
            path = self.output_dir / "architecture.md"
        
        path.write_text(content)
        return path
    
    def _generate_c4_plantuml(
        self,
        structure: Dict[str, Any],
        output: Optional[str] = None
    ) -> Path:
        """Generate C4 PlantUML diagram."""
        lines = [
            "# C4 Architecture",
            "",
            "```plantuml",
            "@startuml",
            "!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml",
            "",
            f"LAYOUT_WITH_LEGEND()",
            "",
            f'Title Container diagram for {self.config.project.name}',
            "",
        ]
        
        # Add containers
        for i, module in enumerate(structure.get("modules", [])[:10]):
            name = module['name'].split('.')[-1]
            lines.append(f'Container(container{i}, "{name}", "Python", "Module")')
        
        lines.extend([
            "",
            "@enduml",
            "```",
            "",
            "*Generated by know*",
        ])
        
        content = "\n".join(lines)
        
        if output:
            path = Path(output)
        else:
            self.output_dir.mkdir(parents=True, exist_ok=True)
            path = self.output_dir / "architecture-c4.md"
        
        path.write_text(content)
        return path
    
    def generate_component_diagram(
        self,
        structure: Dict[str, Any],
        output: Optional[str] = None
    ) -> Path:
        """Generate component-level diagram."""
        return self.generate_c4_diagram(structure, output)
    
    def generate_dependency_graph(
        self,
        structure: Dict[str, Any],
        output: Optional[str] = None
    ) -> Path:
        """Generate dependency graph."""
        lines = [
            "# Dependency Graph",
            "",
            "```mermaid",
            "graph LR",
        ]
        
        # Simplified dependency visualization
        modules = structure.get("modules", [])[:15]
        for module in modules:
            name = module['name'].split('.')[-1]
            lines.append(f'    {name}[{name}]')
        
        lines.extend([
            "```",
            "",
            "*Generated by know*",
        ])
        
        content = "\n".join(lines)
        
        if output:
            path = Path(output)
        else:
            self.output_dir.mkdir(parents=True, exist_ok=True)
            path = self.output_dir / "dependencies.md"
        
        path.write_text(content)
        return path
    
    def generate_openapi(
        self,
        routes: List["APIRoute"],
        output: Optional[str] = None
    ) -> Path:
        """Generate OpenAPI specification."""
        spec = {
            "openapi": "3.0.0",
            "info": {
                "title": self.config.project.name,
                "version": self.config.project.version,
                "description": self.config.project.description
            },
            "paths": {}
        }
        
        for route in routes:
            path = route.path
            if path not in spec["paths"]:
                spec["paths"][path] = {}
            
            method = route.method.lower()
            spec["paths"][path][method] = {
                "summary": route.handler,
                "description": route.docstring or "",
                "responses": {
                    "200": {
                        "description": "Success"
                    }
                }
            }
        
        content = json.dumps(spec, indent=2)
        
        if output:
            path = Path(output)
        else:
            self.output_dir.mkdir(parents=True, exist_ok=True)
            path = self.output_dir / "openapi.json"
        
        path.write_text(content)
        return path
    
    def generate_postman(
        self,
        routes: List["APIRoute"],
        output: Optional[str] = None
    ) -> Path:
        """Generate Postman collection."""
        collection = {
            "info": {
                "name": self.config.project.name,
                "description": self.config.project.description,
                "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
            },
            "item": []
        }
        
        for route in routes:
            item = {
                "name": route.handler,
                "request": {
                    "method": route.method,
                    "header": [],
                    "url": {
                        "raw": route.path,
                        "path": route.path.split("/")
                    },
                    "description": route.docstring or ""
                }
            }
            collection["item"].append(item)
        
        content = json.dumps(collection, indent=2)
        
        if output:
            path = Path(output)
        else:
            self.output_dir.mkdir(parents=True, exist_ok=True)
            path = self.output_dir / "postman-collection.json"
        
        path.write_text(content)
        return path
    
    def generate_api_markdown(
        self,
        routes: List["APIRoute"],
        output: Optional[str] = None
    ) -> Path:
        """Generate API documentation in Markdown."""
        lines = [
            "# API Documentation",
            "",
        ]
        
        # Group by path
        by_path: Dict[str, List["APIRoute"]] = {}
        for route in routes:
            if route.path not in by_path:
                by_path[route.path] = []
            by_path[route.path].append(route)
        
        for path, path_routes in sorted(by_path.items()):
            lines.append(f"## `{path}`")
            lines.append("")
            
            for route in path_routes:
                lines.append(f"### {route.method}")
                lines.append("")
                lines.append(f"**Handler:** `{route.handler}`")
                lines.append("")
                
                if route.docstring:
                    lines.append(route.docstring)
                    lines.append("")
                
                lines.append(f"*File: `{route.file_path}:{route.line_number}`*")
                lines.append("")
        
        content = "\n".join(lines)
        
        if output:
            path = Path(output)
        else:
            self.output_dir.mkdir(parents=True, exist_ok=True)
            path = self.output_dir / "api.md"
        
        path.write_text(content)
        return path
    
    def save_onboarding(
        self,
        guide: str,
        audience: str,
        format: str = "markdown"
    ) -> Path:
        """Save onboarding guide."""
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        safe_audience = audience.replace(" ", "_").lower()
        
        if format == "markdown":
            path = self.output_dir / f"onboarding-{safe_audience}.md"
            path.write_text(guide)
        elif format == "html":
            path = self.output_dir / f"onboarding-{safe_audience}.html"
            html = f"""<!DOCTYPE html>
<html>
<head><title>Onboarding - {audience}</title></head>
<body>
{guide}
</body>
</html>"""
            path.write_text(html)
        else:
            path = self.output_dir / f"onboarding-{safe_audience}.md"
            path.write_text(guide)
        
        return path
    
    def generate_onboarding(
        self,
        structure: Dict[str, Any]
    ) -> Path:
        """Generate default onboarding guide."""
        from know.ai import AISummarizer
        
        ai = AISummarizer(self.config)
        guide = ai.generate_onboarding_guide(structure, "new team members")
        
        return self.save_onboarding(guide, "new-devs")
